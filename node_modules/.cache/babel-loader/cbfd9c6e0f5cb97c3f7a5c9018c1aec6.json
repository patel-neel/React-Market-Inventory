{"ast":null,"code":"var _classCallCheck = require(\"/Users/neelpatel/Desktop/ReactForBeginnersStarterFilesmaster/catchOfTheDay/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/neelpatel/Desktop/ReactForBeginnersStarterFilesmaster/catchOfTheDay/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nvar SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\n\nvar util = require(\"./util\"); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\n\n\nvar REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\nvar NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\n\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\n\nvar SourceNode = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    _classCallCheck(this, SourceNode);\n\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n\n\n  _createClass(SourceNode, [{\n    key: \"add\",\n    value:\n    /**\n     * Add a chunk of generated JS to this source node.\n     *\n     * @param aChunk A string snippet of generated JS code, another instance of\n     *        SourceNode, or an array where each member is one of those things.\n     */\n    function add(aChunk) {\n      if (Array.isArray(aChunk)) {\n        aChunk.forEach(function (chunk) {\n          this.add(chunk);\n        }, this);\n      } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        if (aChunk) {\n          this.children.push(aChunk);\n        }\n      } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n      }\n\n      return this;\n    }\n    /**\n     * Add a chunk of generated JS to the beginning of this source node.\n     *\n     * @param aChunk A string snippet of generated JS code, another instance of\n     *        SourceNode, or an array where each member is one of those things.\n     */\n\n  }, {\n    key: \"prepend\",\n    value: function prepend(aChunk) {\n      if (Array.isArray(aChunk)) {\n        for (var i = aChunk.length - 1; i >= 0; i--) {\n          this.prepend(aChunk[i]);\n        }\n      } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        this.children.unshift(aChunk);\n      } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n      }\n\n      return this;\n    }\n    /**\n     * Walk over the tree of JS snippets in this node and its children. The\n     * walking function is called once for each snippet of JS and is passed that\n     * snippet and the its original associated source's line/column location.\n     *\n     * @param aFn The traversal function.\n     */\n\n  }, {\n    key: \"walk\",\n    value: function walk(aFn) {\n      var chunk;\n\n      for (var i = 0, len = this.children.length; i < len; i++) {\n        chunk = this.children[i];\n\n        if (chunk[isSourceNode]) {\n          chunk.walk(aFn);\n        } else if (chunk !== \"\") {\n          aFn(chunk, {\n            source: this.source,\n            line: this.line,\n            column: this.column,\n            name: this.name\n          });\n        }\n      }\n    }\n    /**\n     * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n     * each of `this.children`.\n     *\n     * @param aSep The separator.\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(aSep) {\n      var newChildren;\n      var i;\n      var len = this.children.length;\n\n      if (len > 0) {\n        newChildren = [];\n\n        for (i = 0; i < len - 1; i++) {\n          newChildren.push(this.children[i]);\n          newChildren.push(aSep);\n        }\n\n        newChildren.push(this.children[i]);\n        this.children = newChildren;\n      }\n\n      return this;\n    }\n    /**\n     * Call String.prototype.replace on the very right-most source snippet. Useful\n     * for trimming whitespace from the end of a source node, etc.\n     *\n     * @param aPattern The pattern to replace.\n     * @param aReplacement The thing to replace the pattern with.\n     */\n\n  }, {\n    key: \"replaceRight\",\n    value: function replaceRight(aPattern, aReplacement) {\n      var lastChild = this.children[this.children.length - 1];\n\n      if (lastChild[isSourceNode]) {\n        lastChild.replaceRight(aPattern, aReplacement);\n      } else if (typeof lastChild === \"string\") {\n        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n      } else {\n        this.children.push(\"\".replace(aPattern, aReplacement));\n      }\n\n      return this;\n    }\n    /**\n     * Set the source content for a source file. This will be added to the SourceMapGenerator\n     * in the sourcesContent field.\n     *\n     * @param aSourceFile The filename of the source file\n     * @param aSourceContent The content of the source file\n     */\n\n  }, {\n    key: \"setSourceContent\",\n    value: function setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    }\n    /**\n     * Walk over the tree of SourceNodes. The walking function is called for each\n     * source file content and is passed the filename and source content.\n     *\n     * @param aFn The traversal function.\n     */\n\n  }, {\n    key: \"walkSourceContents\",\n    value: function walkSourceContents(aFn) {\n      for (var i = 0, len = this.children.length; i < len; i++) {\n        if (this.children[i][isSourceNode]) {\n          this.children[i].walkSourceContents(aFn);\n        }\n      }\n\n      var sources = Object.keys(this.sourceContents);\n\n      for (var _i = 0, _len = sources.length; _i < _len; _i++) {\n        aFn(util.fromSetString(sources[_i]), this.sourceContents[sources[_i]]);\n      }\n    }\n    /**\n     * Return the string representation of this source node. Walks over the tree\n     * and concatenates all the various snippets together to one string.\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var str = \"\";\n      this.walk(function (chunk) {\n        str += chunk;\n      });\n      return str;\n    }\n    /**\n     * Returns the string representation of this source node along with a source\n     * map.\n     */\n\n  }, {\n    key: \"toStringWithSourceMap\",\n    value: function toStringWithSourceMap(aArgs) {\n      var generated = {\n        code: \"\",\n        line: 1,\n        column: 0\n      };\n      var map = new SourceMapGenerator(aArgs);\n      var sourceMappingActive = false;\n      var lastOriginalSource = null;\n      var lastOriginalLine = null;\n      var lastOriginalColumn = null;\n      var lastOriginalName = null;\n      this.walk(function (chunk, original) {\n        generated.code += chunk;\n\n        if (original.source !== null && original.line !== null && original.column !== null) {\n          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n\n          lastOriginalSource = original.source;\n          lastOriginalLine = original.line;\n          lastOriginalColumn = original.column;\n          lastOriginalName = original.name;\n          sourceMappingActive = true;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            generated: {\n              line: generated.line,\n              column: generated.column\n            }\n          });\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        }\n\n        for (var idx = 0, length = chunk.length; idx < length; idx++) {\n          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n            generated.line++;\n            generated.column = 0; // Mappings end at eol\n\n            if (idx + 1 === length) {\n              lastOriginalSource = null;\n              sourceMappingActive = false;\n            } else if (sourceMappingActive) {\n              map.addMapping({\n                source: original.source,\n                original: {\n                  line: original.line,\n                  column: original.column\n                },\n                generated: {\n                  line: generated.line,\n                  column: generated.column\n                },\n                name: original.name\n              });\n            }\n          } else {\n            generated.column++;\n          }\n        }\n      });\n      this.walkSourceContents(function (sourceFile, sourceContent) {\n        map.setSourceContent(sourceFile, sourceContent);\n      });\n      return {\n        code: generated.code,\n        map\n      };\n    }\n  }], [{\n    key: \"fromStringWithSourceMap\",\n    value: function fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n      // The SourceNode we want to fill with the generated code\n      // and the SourceMap\n      var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n      // while all odd indices are the newlines between two adjacent lines\n      // (since `REGEX_NEWLINE` captures its match).\n      // Processed fragments are accessed by calling `shiftNextLine`.\n\n      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n      var remainingLinesIndex = 0;\n\n      var shiftNextLine = function shiftNextLine() {\n        var lineContents = getNextLine(); // The last line of a file might not have a newline.\n\n        var newLine = getNextLine() || \"\";\n        return lineContents + newLine;\n\n        function getNextLine() {\n          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n        }\n      }; // We need to remember the position of \"remainingLines\"\n\n\n      var lastGeneratedLine = 1,\n          lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n      // To extract it current and last mapping is used.\n      // Here we store the last mapping.\n\n      var lastMapping = null;\n      var nextLine;\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        if (lastMapping !== null) {\n          // We add the code from \"lastMapping\" to \"mapping\":\n          // First check if there is a new line in between.\n          if (lastGeneratedLine < mapping.generatedLine) {\n            // Associate first line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n            lastGeneratedLine++;\n            lastGeneratedColumn = 0; // The remaining code is added without mapping\n          } else {\n            // There is no new line in between.\n            // Associate the code between \"lastGeneratedColumn\" and\n            // \"mapping.generatedColumn\" with \"lastMapping\"\n            nextLine = remainingLines[remainingLinesIndex] || \"\";\n            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n            lastMapping = mapping;\n            return;\n          }\n        } // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n\n\n        while (lastGeneratedLine < mapping.generatedLine) {\n          node.add(shiftNextLine());\n          lastGeneratedLine++;\n        }\n\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          node.add(nextLine.substr(0, mapping.generatedColumn));\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n        }\n\n        lastMapping = mapping;\n      }, this); // We have processed all mappings.\n\n      if (remainingLinesIndex < remainingLines.length) {\n        if (lastMapping) {\n          // Associate the remaining code in the current line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n        } // and add the remaining lines without any mapping\n\n\n        node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n      } // Copy sourcesContent into SourceNode\n\n\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n        if (content != null) {\n          if (aRelativePath != null) {\n            sourceFile = util.join(aRelativePath, sourceFile);\n          }\n\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n      return node;\n\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n        }\n      }\n    }\n  }]);\n\n  return SourceNode;\n}();\n\nexports.SourceNode = SourceNode;","map":{"version":3,"sources":["/Users/neelpatel/Desktop/ReactForBeginnersStarterFilesmaster/catchOfTheDay/node_modules/stylus/node_modules/source-map/lib/source-node.js"],"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","aChunk","Array","isArray","forEach","chunk","push","TypeError","i","length","prepend","unshift","aFn","len","walk","aSep","newChildren","aPattern","aReplacement","lastChild","replaceRight","replace","aSourceFile","aSourceContent","toSetString","walkSourceContents","sources","Object","keys","fromSetString","str","aArgs","generated","code","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceFile","sourceContent","setSourceContent","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","nextLine","eachMapping","mapping","generatedLine","addMappingWithCode","substr","generatedColumn","splice","join","content","sourceContentFor","originalLine","originalColumn","exports"],"mappings":"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","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\nconst util = require(\"./util\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function() {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function(chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, { source: this.source,\n                      line: this.line,\n                      column: this.column,\n                      name: this.name });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function(chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function(chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if (lastOriginalSource !== original.source\n          || lastOriginalLine !== original.line\n          || lastOriginalColumn !== original.column\n          || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map };\n  }\n}\n\nexports.SourceNode = SourceNode;\n"]},"metadata":{},"sourceType":"script"}