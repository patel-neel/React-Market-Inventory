{"ast":null,"code":"/*!\n * Stylus - utils\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar nodes = require('./nodes'),\n    basename = require('path').basename,\n    relative = require('path').relative,\n    join = require('path').join,\n    isAbsolute = require('path').isAbsolute,\n    glob = require('glob'),\n    fs = require('fs');\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\n\nexports.absolute = isAbsolute || function (path) {\n  // On Windows the path could start with a drive letter, i.e. a:\\\\ or two leading backslashes.\n  // Also on Windows, the path may have been normalized to forward slashes, so check for this too.\n  return path.substr(0, 2) == '\\\\\\\\' || '/' === path.charAt(0) || /^[a-z]:[\\\\\\/]/i.test(path);\n};\n/**\n * Attempt to lookup `path` within `paths` from tail to head.\n * Optionally a path to `ignore` may be passed.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {String}\n * @api private\n */\n\n\nexports.lookup = function (path, paths, ignore) {\n  var lookup,\n      i = paths.length; // Absolute\n\n  if (exports.absolute(path)) {\n    try {\n      fs.statSync(path);\n      return path;\n    } catch (err) {// Ignore, continue on\n      // to trying relative lookup.\n      // Needed for url(/images/foo.png)\n      // for example\n    }\n  } // Relative\n\n\n  while (i--) {\n    try {\n      lookup = join(paths[i], path);\n      if (ignore == lookup) continue;\n      fs.statSync(lookup);\n      return lookup;\n    } catch (err) {// Ignore\n    }\n  }\n};\n/**\n * Like `utils.lookup` but uses `glob` to find files.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {Array}\n * @api private\n */\n\n\nexports.find = function (path, paths, ignore) {\n  var lookup,\n      found,\n      i = paths.length; // Absolute\n\n  if (exports.absolute(path)) {\n    if ((found = glob.sync(path)).length) {\n      return found;\n    }\n  } // Relative\n\n\n  while (i--) {\n    lookup = join(paths[i], path);\n    if (ignore == lookup) continue;\n\n    if ((found = glob.sync(lookup)).length) {\n      return found;\n    }\n  }\n};\n/**\n * Lookup index file inside dir with given `name`.\n *\n * @param {String} name\n * @return {Array}\n * @api private\n */\n\n\nexports.lookupIndex = function (name, paths, filename) {\n  // foo/index.styl\n  var found = exports.find(join(name, 'index.styl'), paths, filename);\n\n  if (!found) {\n    // foo/foo.styl\n    found = exports.find(join(name, basename(name).replace(/\\.styl/i, '') + '.styl'), paths, filename);\n  }\n\n  if (!found && !~name.indexOf('node_modules')) {\n    // node_modules/foo/.. or node_modules/foo.styl/..\n    found = lookupPackage(join('node_modules', name));\n  }\n\n  return found;\n\n  function lookupPackage(dir) {\n    var pkg = exports.lookup(join(dir, 'package.json'), paths, filename);\n\n    if (!pkg) {\n      return /\\.styl$/i.test(dir) ? exports.lookupIndex(dir, paths, filename) : lookupPackage(dir + '.styl');\n    }\n\n    var main = require(relative(__dirname, pkg)).main;\n\n    if (main) {\n      found = exports.find(join(dir, main), paths, filename);\n    } else {\n      found = exports.lookupIndex(dir, paths, filename);\n    }\n\n    return found;\n  }\n};\n/**\n * Format the given `err` with the given `options`.\n *\n * Options:\n *\n *   - `filename`   context filename\n *   - `context`    context line count [8]\n *   - `lineno`     context line number\n *   - `column`     context column number\n *   - `input`        input string\n *\n * @param {Error} err\n * @param {Object} options\n * @return {Error}\n * @api private\n */\n\n\nexports.formatException = function (err, options) {\n  var lineno = options.lineno,\n      column = options.column,\n      filename = options.filename,\n      str = options.input,\n      context = options.context || 8,\n      context = context / 2,\n      lines = ('\\n' + str).split('\\n'),\n      start = Math.max(lineno - context, 1),\n      end = Math.min(lines.length, lineno + context),\n      pad = end.toString().length;\n  var context = lines.slice(start, end).map(function (line, i) {\n    var curr = i + start;\n    return '   ' + Array(pad - curr.toString().length + 1).join(' ') + curr + '| ' + line + (curr == lineno ? '\\n' + Array(curr.toString().length + 5 + column).join('-') + '^' : '');\n  }).join('\\n');\n  err.message = filename + ':' + lineno + ':' + column + '\\n' + context + '\\n\\n' + err.message + '\\n' + (err.stylusStack ? err.stylusStack + '\\n' : ''); // Don't show JS stack trace for Stylus errors\n\n  if (err.fromStylus) err.stack = 'Error: ' + err.message;\n  return err;\n};\n/**\n * Assert that `node` is of the given `type`, or throw.\n *\n * @param {Node} node\n * @param {Function} type\n * @param {String} param\n * @api public\n */\n\n\nexports.assertType = function (node, type, param) {\n  exports.assertPresent(node, param);\n  if (node.nodeName == type) return;\n  var actual = node.nodeName,\n      msg = 'expected ' + (param ? '\"' + param + '\" to be a ' : '') + type + ', but got ' + actual + ':' + node;\n  throw new Error('TypeError: ' + msg);\n};\n/**\n * Assert that `node` is a `String` or `Ident`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\n\nexports.assertString = function (node, param) {\n  exports.assertPresent(node, param);\n\n  switch (node.nodeName) {\n    case 'string':\n    case 'ident':\n    case 'literal':\n      return;\n\n    default:\n      var actual = node.nodeName,\n          msg = 'expected string, ident or literal, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n/**\n * Assert that `node` is a `RGBA` or `HSLA`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\n\nexports.assertColor = function (node, param) {\n  exports.assertPresent(node, param);\n\n  switch (node.nodeName) {\n    case 'rgba':\n    case 'hsla':\n      return;\n\n    default:\n      var actual = node.nodeName,\n          msg = 'expected rgba or hsla, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n/**\n * Assert that param `name` is given, aka the `node` is passed.\n *\n * @param {Node} node\n * @param {String} name\n * @api public\n */\n\n\nexports.assertPresent = function (node, name) {\n  if (node) return;\n  if (name) throw new Error('\"' + name + '\" argument required');\n  throw new Error('argument missing');\n};\n/**\n * Unwrap `expr`.\n *\n * Takes an expressions with length of 1\n * such as `((1 2 3))` and unwraps it to `(1 2 3)`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\n\nexports.unwrap = function (expr) {\n  // explicitly preserve the expression\n  if (expr.preserve) return expr;\n  if ('arguments' != expr.nodeName && 'expression' != expr.nodeName) return expr;\n  if (1 != expr.nodes.length) return expr;\n  if ('arguments' != expr.nodes[0].nodeName && 'expression' != expr.nodes[0].nodeName) return expr;\n  return exports.unwrap(expr.nodes[0]);\n};\n/**\n * Coerce JavaScript values to their Stylus equivalents.\n *\n * @param {Mixed} val\n * @param {Boolean} [raw]\n * @return {Node}\n * @api public\n */\n\n\nexports.coerce = function (val, raw) {\n  switch (typeof val) {\n    case 'function':\n      return val;\n\n    case 'string':\n      return new nodes.String(val);\n\n    case 'boolean':\n      return new nodes.Boolean(val);\n\n    case 'number':\n      return new nodes.Unit(val);\n\n    default:\n      if (null == val) return nodes.null;\n      if (Array.isArray(val)) return exports.coerceArray(val, raw);\n      if (val.nodeName) return val;\n      return exports.coerceObject(val, raw);\n  }\n};\n/**\n * Coerce a javascript `Array` to a Stylus `Expression`.\n *\n * @param {Array} val\n * @param {Boolean} [raw]\n * @return {Expression}\n * @api private\n */\n\n\nexports.coerceArray = function (val, raw) {\n  var expr = new nodes.Expression();\n  val.forEach(function (val) {\n    expr.push(exports.coerce(val, raw));\n  });\n  return expr;\n};\n/**\n * Coerce a javascript object to a Stylus `Expression` or `Object`.\n *\n * For example `{ foo: 'bar', bar: 'baz' }` would become\n * the expression `(foo 'bar') (bar 'baz')`. If `raw` is true\n * given `obj` would become a Stylus hash object.\n *\n * @param {Object} obj\n * @param {Boolean} [raw]\n * @return {Expression|Object}\n * @api public\n */\n\n\nexports.coerceObject = function (obj, raw) {\n  var node = raw ? new nodes.Object() : new nodes.Expression(),\n      val;\n\n  for (var key in obj) {\n    val = exports.coerce(obj[key], raw);\n    key = new nodes.Ident(key);\n\n    if (raw) {\n      node.set(key, val);\n    } else {\n      node.push(exports.coerceArray([key, val]));\n    }\n  }\n\n  return node;\n};\n/**\n * Return param names for `fn`.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\n\nexports.params = function (fn) {\n  return fn.toString().match(/\\(([^)]*)\\)/)[1].split(/ *, */);\n};\n/**\n * Merge object `b` with `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Boolean} [deep]\n * @return {Object} a\n * @api private\n */\n\n\nexports.merge = function (a, b, deep) {\n  for (var k in b) {\n    if (deep && a[k]) {\n      var nodeA = exports.unwrap(a[k]).first,\n          nodeB = exports.unwrap(b[k]).first;\n\n      if ('object' == nodeA.nodeName && 'object' == nodeB.nodeName) {\n        a[k].first.vals = exports.merge(nodeA.vals, nodeB.vals, deep);\n      } else {\n        a[k] = b[k];\n      }\n    } else {\n      a[k] = b[k];\n    }\n  }\n\n  return a;\n};\n/**\n * Returns an array with unique values.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\n\nexports.uniq = function (arr) {\n  var obj = {},\n      ret = [];\n\n  for (var i = 0, len = arr.length; i < len; ++i) {\n    if (arr[i] in obj) continue;\n    obj[arr[i]] = true;\n    ret.push(arr[i]);\n  }\n\n  return ret;\n};\n/**\n * Compile selector strings in `arr` from the bottom-up\n * to produce the selector combinations. For example\n * the following Stylus:\n *\n *    ul\n *      li\n *      p\n *        a\n *          color: red\n *\n * Would return:\n *\n *      [ 'ul li a', 'ul p a' ]\n *\n * @param {Array} arr\n * @param {Boolean} leaveHidden\n * @return {Array}\n * @api private\n */\n\n\nexports.compileSelectors = function (arr, leaveHidden) {\n  var selectors = [],\n      Parser = require('./selector-parser'),\n      indent = this.indent || '',\n      buf = [];\n\n  function parse(selector, buf) {\n    var parts = [selector.val],\n        str = new Parser(parts[0], parents, parts).parse().val,\n        parents = [];\n\n    if (buf.length) {\n      for (var i = 0, len = buf.length; i < len; ++i) {\n        parts.push(buf[i]);\n        parents.push(str);\n        var child = new Parser(buf[i], parents, parts).parse();\n\n        if (child.nested) {\n          str += ' ' + child.val;\n        } else {\n          str = child.val;\n        }\n      }\n    }\n\n    return str.trim();\n  }\n\n  function compile(arr, i) {\n    if (i) {\n      arr[i].forEach(function (selector) {\n        if (!leaveHidden && selector.isPlaceholder) return;\n\n        if (selector.inherits) {\n          buf.unshift(selector.val);\n          compile(arr, i - 1);\n          buf.shift();\n        } else {\n          selectors.push(indent + parse(selector, buf));\n        }\n      });\n    } else {\n      arr[0].forEach(function (selector) {\n        if (!leaveHidden && selector.isPlaceholder) return;\n        var str = parse(selector, buf);\n        if (str) selectors.push(indent + str);\n      });\n    }\n  }\n\n  compile(arr, arr.length - 1); // Return the list with unique selectors only\n\n  return exports.uniq(selectors);\n};\n/**\n * Attempt to parse string.\n *\n * @param {String} str\n * @return {Node}\n * @api private\n */\n\n\nexports.parseString = function (str) {\n  var Parser = require('./parser'),\n      parser,\n      ret;\n\n  try {\n    parser = new Parser(str);\n    ret = parser.list();\n  } catch (e) {\n    ret = new nodes.Literal(str);\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["/Users/neelpatel/Desktop/ReactForBeginnersStarterFilesmaster/catchOfTheDay/node_modules/stylus/lib/utils.js"],"names":["nodes","require","basename","relative","join","isAbsolute","glob","fs","exports","absolute","path","substr","charAt","test","lookup","paths","ignore","i","length","statSync","err","find","found","sync","lookupIndex","name","filename","replace","indexOf","lookupPackage","dir","pkg","main","__dirname","formatException","options","lineno","column","str","input","context","lines","split","start","Math","max","end","min","pad","toString","slice","map","line","curr","Array","message","stylusStack","fromStylus","stack","assertType","node","type","param","assertPresent","nodeName","actual","msg","Error","assertString","assertColor","unwrap","expr","preserve","coerce","val","raw","String","Boolean","Unit","null","isArray","coerceArray","coerceObject","Expression","forEach","push","obj","Object","key","Ident","set","params","fn","match","merge","a","b","deep","k","nodeA","first","nodeB","vals","uniq","arr","ret","len","compileSelectors","leaveHidden","selectors","Parser","indent","buf","parse","selector","parts","parents","child","nested","trim","compile","isPlaceholder","inherits","unshift","shift","parseString","parser","list","e","Literal"],"mappings":"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","sourcesContent":["\n/*!\n * Stylus - utils\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar nodes = require('./nodes')\n  , basename = require('path').basename\n  , relative = require('path').relative\n  , join = require('path').join\n  , isAbsolute = require('path').isAbsolute\n  , glob = require('glob')\n  , fs = require('fs');\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.absolute = isAbsolute || function(path){\n  // On Windows the path could start with a drive letter, i.e. a:\\\\ or two leading backslashes.\n  // Also on Windows, the path may have been normalized to forward slashes, so check for this too.\n  return path.substr(0, 2) == '\\\\\\\\' || '/' === path.charAt(0) || /^[a-z]:[\\\\\\/]/i.test(path);\n};\n\n/**\n * Attempt to lookup `path` within `paths` from tail to head.\n * Optionally a path to `ignore` may be passed.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {String}\n * @api private\n */\n\nexports.lookup = function(path, paths, ignore){\n  var lookup\n    , i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    try {\n      fs.statSync(path);\n      return path;\n    } catch (err) {\n      // Ignore, continue on\n      // to trying relative lookup.\n      // Needed for url(/images/foo.png)\n      // for example\n    }\n  }\n\n  // Relative\n  while (i--) {\n    try {\n      lookup = join(paths[i], path);\n      if (ignore == lookup) continue;\n      fs.statSync(lookup);\n      return lookup;\n    } catch (err) {\n      // Ignore\n    }\n  }\n};\n\n/**\n * Like `utils.lookup` but uses `glob` to find files.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {Array}\n * @api private\n */\nexports.find = function(path, paths, ignore) {\n  var lookup\n    , found\n    , i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    if ((found = glob.sync(path)).length) {\n      return found;\n    }\n  }\n\n  // Relative\n  while (i--) {\n    lookup = join(paths[i], path);\n    if (ignore == lookup) continue;\n    if ((found = glob.sync(lookup)).length) {\n      return found;\n    }\n  }\n};\n\n/**\n * Lookup index file inside dir with given `name`.\n *\n * @param {String} name\n * @return {Array}\n * @api private\n */\n\nexports.lookupIndex = function(name, paths, filename){\n  // foo/index.styl\n  var found = exports.find(join(name, 'index.styl'), paths, filename);\n  if (!found) {\n    // foo/foo.styl\n    found = exports.find(join(name, basename(name).replace(/\\.styl/i, '') + '.styl'), paths, filename);\n  }\n  if (!found && !~name.indexOf('node_modules')) {\n    // node_modules/foo/.. or node_modules/foo.styl/..\n    found = lookupPackage(join('node_modules', name));\n  }\n  return found;\n\n  function lookupPackage(dir) {\n    var pkg = exports.lookup(join(dir, 'package.json'), paths, filename);\n    if (!pkg) {\n      return /\\.styl$/i.test(dir) ? exports.lookupIndex(dir, paths, filename) : lookupPackage(dir + '.styl');\n    }\n    var main = require(relative(__dirname, pkg)).main;\n    if (main) {\n      found = exports.find(join(dir, main), paths, filename);\n    } else {\n      found = exports.lookupIndex(dir, paths, filename);\n    }\n    return found;\n  }\n};\n\n/**\n * Format the given `err` with the given `options`.\n *\n * Options:\n *\n *   - `filename`   context filename\n *   - `context`    context line count [8]\n *   - `lineno`     context line number\n *   - `column`     context column number\n *   - `input`        input string\n *\n * @param {Error} err\n * @param {Object} options\n * @return {Error}\n * @api private\n */\n\nexports.formatException = function(err, options){\n  var lineno = options.lineno\n    , column = options.column\n    , filename = options.filename\n    , str = options.input\n    , context = options.context || 8\n    , context = context / 2\n    , lines = ('\\n' + str).split('\\n')\n    , start = Math.max(lineno - context, 1)\n    , end = Math.min(lines.length, lineno + context)\n    , pad = end.toString().length;\n\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start;\n    return '   '\n      + Array(pad - curr.toString().length + 1).join(' ')\n      + curr\n      + '| '\n      + line\n      + (curr == lineno\n        ? '\\n' + Array(curr.toString().length + 5 + column).join('-') + '^'\n        : '');\n  }).join('\\n');\n\n  err.message = filename\n    + ':' + lineno\n    + ':' + column\n    + '\\n' + context\n    + '\\n\\n' + err.message + '\\n'\n    + (err.stylusStack ? err.stylusStack + '\\n' : '');\n\n  // Don't show JS stack trace for Stylus errors\n  if (err.fromStylus) err.stack = 'Error: ' + err.message;\n\n  return err;\n};\n\n/**\n * Assert that `node` is of the given `type`, or throw.\n *\n * @param {Node} node\n * @param {Function} type\n * @param {String} param\n * @api public\n */\n\nexports.assertType = function(node, type, param){\n  exports.assertPresent(node, param);\n  if (node.nodeName == type) return;\n  var actual = node.nodeName\n    , msg = 'expected '\n      + (param ? '\"' + param + '\" to be a ' :  '')\n      + type + ', but got '\n      + actual + ':' + node;\n  throw new Error('TypeError: ' + msg);\n};\n\n/**\n * Assert that `node` is a `String` or `Ident`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertString = function(node, param){\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'string':\n    case 'ident':\n    case 'literal':\n      return;\n    default:\n      var actual = node.nodeName\n        , msg = 'expected string, ident or literal, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that `node` is a `RGBA` or `HSLA`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertColor = function(node, param){\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'rgba':\n    case 'hsla':\n      return;\n    default:\n      var actual = node.nodeName\n        , msg = 'expected rgba or hsla, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that param `name` is given, aka the `node` is passed.\n *\n * @param {Node} node\n * @param {String} name\n * @api public\n */\n\nexports.assertPresent = function(node, name){\n  if (node) return;\n  if (name) throw new Error('\"' + name + '\" argument required');\n  throw new Error('argument missing');\n};\n\n/**\n * Unwrap `expr`.\n *\n * Takes an expressions with length of 1\n * such as `((1 2 3))` and unwraps it to `(1 2 3)`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\nexports.unwrap = function(expr){\n  // explicitly preserve the expression\n  if (expr.preserve) return expr;\n  if ('arguments' != expr.nodeName && 'expression' != expr.nodeName) return expr;\n  if (1 != expr.nodes.length) return expr;\n  if ('arguments' != expr.nodes[0].nodeName && 'expression' != expr.nodes[0].nodeName) return expr;\n  return exports.unwrap(expr.nodes[0]);\n};\n\n/**\n * Coerce JavaScript values to their Stylus equivalents.\n *\n * @param {Mixed} val\n * @param {Boolean} [raw]\n * @return {Node}\n * @api public\n */\n\nexports.coerce = function(val, raw){\n  switch (typeof val) {\n    case 'function':\n      return val;\n    case 'string':\n      return new nodes.String(val);\n    case 'boolean':\n      return new nodes.Boolean(val);\n    case 'number':\n      return new nodes.Unit(val);\n    default:\n      if (null == val) return nodes.null;\n      if (Array.isArray(val)) return exports.coerceArray(val, raw);\n      if (val.nodeName) return val;\n      return exports.coerceObject(val, raw);\n  }\n};\n\n/**\n * Coerce a javascript `Array` to a Stylus `Expression`.\n *\n * @param {Array} val\n * @param {Boolean} [raw]\n * @return {Expression}\n * @api private\n */\n\nexports.coerceArray = function(val, raw){\n  var expr = new nodes.Expression;\n  val.forEach(function(val){\n    expr.push(exports.coerce(val, raw));\n  });\n  return expr;\n};\n\n/**\n * Coerce a javascript object to a Stylus `Expression` or `Object`.\n *\n * For example `{ foo: 'bar', bar: 'baz' }` would become\n * the expression `(foo 'bar') (bar 'baz')`. If `raw` is true\n * given `obj` would become a Stylus hash object.\n *\n * @param {Object} obj\n * @param {Boolean} [raw]\n * @return {Expression|Object}\n * @api public\n */\n\nexports.coerceObject = function(obj, raw){\n  var node = raw ? new nodes.Object : new nodes.Expression\n    , val;\n\n  for (var key in obj) {\n    val = exports.coerce(obj[key], raw);\n    key = new nodes.Ident(key);\n    if (raw) {\n      node.set(key, val);\n    } else {\n      node.push(exports.coerceArray([key, val]));\n    }\n  }\n\n  return node;\n};\n\n/**\n * Return param names for `fn`.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\nexports.params = function(fn){\n  return fn\n    .toString()\n    .match(/\\(([^)]*)\\)/)[1].split(/ *, */);\n};\n\n/**\n * Merge object `b` with `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Boolean} [deep]\n * @return {Object} a\n * @api private\n */\nexports.merge = function(a, b, deep) {\n  for (var k in b) {\n    if (deep && a[k]) {\n      var nodeA = exports.unwrap(a[k]).first\n        , nodeB = exports.unwrap(b[k]).first;\n\n      if ('object' == nodeA.nodeName && 'object' == nodeB.nodeName) {\n        a[k].first.vals = exports.merge(nodeA.vals, nodeB.vals, deep);\n      } else {\n        a[k] = b[k];\n      }\n    } else {\n      a[k] = b[k];\n    }\n  }\n  return a;\n};\n\n/**\n * Returns an array with unique values.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.uniq = function(arr){\n  var obj = {}\n    , ret = [];\n\n  for (var i = 0, len = arr.length; i < len; ++i) {\n    if (arr[i] in obj) continue;\n\n    obj[arr[i]] = true;\n    ret.push(arr[i]);\n  }\n  return ret;\n};\n\n/**\n * Compile selector strings in `arr` from the bottom-up\n * to produce the selector combinations. For example\n * the following Stylus:\n *\n *    ul\n *      li\n *      p\n *        a\n *          color: red\n *\n * Would return:\n *\n *      [ 'ul li a', 'ul p a' ]\n *\n * @param {Array} arr\n * @param {Boolean} leaveHidden\n * @return {Array}\n * @api private\n */\n\nexports.compileSelectors = function(arr, leaveHidden){\n  var selectors = []\n    , Parser = require('./selector-parser')\n    , indent = (this.indent || '')\n    , buf = [];\n\n  function parse(selector, buf) {\n    var parts = [selector.val]\n      , str = new Parser(parts[0], parents, parts).parse().val\n      , parents = [];\n\n    if (buf.length) {\n      for (var i = 0, len = buf.length; i < len; ++i) {\n        parts.push(buf[i]);\n        parents.push(str);\n        var child = new Parser(buf[i], parents, parts).parse();\n\n        if (child.nested) {\n          str += ' ' + child.val;\n        } else {\n          str = child.val;\n        }\n      }\n    }\n    return str.trim();\n  }\n\n  function compile(arr, i) {\n    if (i) {\n      arr[i].forEach(function(selector){\n        if (!leaveHidden && selector.isPlaceholder) return;\n        if (selector.inherits) {\n          buf.unshift(selector.val);\n          compile(arr, i - 1);\n          buf.shift();\n        } else {\n          selectors.push(indent + parse(selector, buf));\n        }\n      });\n    } else {\n      arr[0].forEach(function(selector){\n        if (!leaveHidden && selector.isPlaceholder) return;\n        var str = parse(selector, buf);\n        if (str) selectors.push(indent + str);\n      });\n    }\n  }\n\n  compile(arr, arr.length - 1);\n\n  // Return the list with unique selectors only\n  return exports.uniq(selectors);\n};\n\n/**\n * Attempt to parse string.\n *\n * @param {String} str\n * @return {Node}\n * @api private\n */\n\nexports.parseString = function(str){\n  var Parser = require('./parser')\n    , parser\n    , ret;\n\n  try {\n    parser = new Parser(str);\n    ret = parser.list();\n  } catch (e) {\n    ret = new nodes.Literal(str);\n  }\n  return ret;\n};\n"]},"metadata":{},"sourceType":"script"}